import os
import yaml

from osgeo.gdal import GDT_Float64
import numpy as np
import pygeoprocessing.geoprocessing as geo

from . import cropland
from . import carbon_new
from . import grazing
from . import biodiversity
from . import forestry





def evaluate_landscape(
    args_file, scenario_file, bau_file, country_nci_folder, output_folder,
    run_biodiversity=True, run_carbon=True, run_cropland=True, run_grazing=True,
    run_forestry=True, run_transition_cost=True):
    """
    This is a function that can be run after the main NCI analysis to evaluate other landscapes.

    Inputs:
    - `args`: dictionary generated from the config file that produced the main analysis
    - `scenario_file`: path to the .tif file with the landscape to be analyzed
    - `bau_file`: path to .tif file for baseline - only used to calculate transition costs.
    - `country_nci_folder`: path to the country-level "InputRasters" folder generated by NCI
    - `output_folder`: location to put the model outputs.
    """

    if not os.path.isdir(output_folder):
        os.makedirs(output_folder)
    
    with open(args_file, 'r') as f:
        args = yaml.safe_load(f)

    lu_table_file = args["lu_table_file"]
    raster_input_folder = os.path.join(country_nci_folder, "InputRasters")
    # Need to assemble the correct argument dictionary to run the evaluate functions for each model
    
    # BIODIVERSITY
    if run_biodiversity:
        minValues = {
            'Richness': 0.,
            'RedList': 0.,
            'Endemics': 0.,
            'KBAs': 0.,
            'Ecoregion': 0.
        }
        biodiv_args = {
            "preProcessing": False,
            "raster_input_folder": os.path.join(raster_input_folder, "biodiversity"),
            "lu_raster": scenario_file,
            "restoration_raster": os.path.join(country_nci_folder, "ScenarioMaps", "restoration.tif"),
            "target_folder": output_folder,
            "lu_codes_table": lu_table_file,
            "predicts_table_1_path": args["biodiversity"]["predicts_table_1"],
            "predicts_table_2_path": args["biodiversity"]["predicts_table_2"],
            "minValues": minValues,
            "maxValuesFile": os.path.join(raster_input_folder, "biodiversity", "max_values.csv")
        }
        biodiversity.execute(biodiv_args)

    # CARBON
    if run_carbon:
        carbon_args = {
            "raster_input_folder": raster_input_folder,
            "lu_raster": scenario_file, 
            "potential_vegetation": os.path.join(raster_input_folder, "potential_vegetation.tif"),
            "target_folder": output_folder,
            "lu_codes_table": lu_table_file,
            "carbon_zone_file": os.path.join(raster_input_folder, "carbon_zone_file.tif"),
            "carbon_table_file": args["carbon"]["carbon_table_file"],
            "pixel_area": os.path.join(raster_input_folder, "pixel_area.tif")
        }
        print(carbon_args)
        carbon_new.execute(carbon_args)

    # CROPLAND
    if run_cropland:
        cropland_args = {
            "lu_raster": scenario_file, 
            "target_folder": output_folder,
            "lu_codes_table": lu_table_file,
            "cropland_current_value": os.path.join(raster_input_folder, "crop_value_current.tif"),
            "cropland_irrigated_value": os.path.join(raster_input_folder, "crop_value_intensified_irrigated.tif"),
            "cropland_rainfed_value": os.path.join(raster_input_folder, "crop_value_intensified_rainfed.tif"),
            "pixel_area": os.path.join(raster_input_folder, "pixel_area.tif"),
            "set_zero_floor": True
        }
        cropland.execute(cropland_args)

    # FORESTRY
    if run_forestry:
        forestry_args = {
            "lu_raster": scenario_file, 
            "target_folder": output_folder,
            "lu_codes_table": lu_table_file,
            "forestry_value_raster": os.path.join(raster_input_folder, "forestry_value.tif"),
            "pixel_area": os.path.join(raster_input_folder, "pixel_area.tif")
        }
        forestry.execute(forestry_args)

    # GRAZING
    if run_grazing:
        grazing_args = {
            "lu_raster": scenario_file, 
            "target_folder": output_folder,
            "lu_codes_table": lu_table_file,
            "current_grazing_value_raster": os.path.join(raster_input_folder, "grazing_current_value.tif"),
            "potential_grazing_value_raster": os.path.join(raster_input_folder, "grazing_potential_value.tif"),
            "current_grazing_methane_raster": os.path.join(raster_input_folder, "grazing_current_methane.tif"),
            "potential_grazing_methane_raster": os.path.join(raster_input_folder, "grazing_potential_methane.tif"),
            "pixel_area": os.path.join(raster_input_folder, "pixel_area.tif")
        }
        grazing.execute(grazing_args)

    # TRANSITION COST
    if run_transition_cost:
        transition_cost(
            scenario_file,
            bau_file,
            os.path.join(raster_input_folder, "transition_cost"),
            output_folder
        )




def transition_cost(scenario_map, bau_map, nci_transition_cost_folder, output_folder):
    """
    This is a lookup-based version of the transition cost function that reads
    the appropriate pixel level values from the scenario-level rasters in
    `nci_transition_cost_folder`. 

    We're looking for pixels that have:
    - restoration
    - added irrigation
    - BMPs
    """

    cost_map_restoration = os.path.join(nci_transition_cost_folder, "tran_cost_restoration.tif")
    cost_map_irrigated = os.path.join(nci_transition_cost_folder, "tran_cost_extensification_intensified_irrigated.tif")
    cost_map_rainfed_bmps = os.path.join(nci_transition_cost_folder, "tran_cost_extensification_bmps_rainfed.tif")
    cost_map_irrigated_bmps = os.path.join(nci_transition_cost_folder, "tran_cost_extensification_bmps_irrigated.tif")

    natural_codes_min = 50
    natural_codes_max = 180


    def local_op(sm, bau, cr, ci, crb, cib):

        cost = np.zeros_like(sm, dtype=float)

        # Restoration costs
        non_nat_bau = np.all([
            np.any([bau < natural_codes_min, bau > natural_codes_max], axis=0),
            bau != 255
        ], axis=0)
        restored_pix = np.all([
            non_nat_bau,
            sm >= natural_codes_min,
            sm <= natural_codes_max
        ], axis=0)
        cost[restored_pix] = cr[restored_pix]

        # Intensified irrigation
        irrigated_pix = np.all([
            bau != 20,
            sm == 25
        ], axis=0)
        cost[irrigated_pix] = ci[irrigated_pix]

        # Rainfed with BMPS
        rfbmp_pix = sm == 16
        cost[rfbmp_pix] = crb[rfbmp_pix]

        # Irrigated with BMPS
        irbmp_pix = sm == 26
        cost[irbmp_pix] = cib[irbmp_pix]

        # NODATA
        cost[bau==255] = -9999

        return cost
    

    src_rasters = [scenario_map, bau_map, cost_map_restoration,
                   cost_map_irrigated, cost_map_rainfed_bmps, cost_map_irrigated_bmps]
    output_file = os.path.join(
        output_folder, 
        f"{os.path.splitext(os.path.basename(scenario_map))[0]}_transition_cost.tif"
    )
    geo.raster_calculator(
        [(r, 1) for r in src_rasters],
        local_op,
        output_file,
        GDT_Float64,
        -9999
    )






