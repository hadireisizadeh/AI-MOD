from __future__ import annotations

import os
import h5py
import pandas as pd
import numpy as np
import osgeo.gdal as gdal
import geopandas as gpd
import pygeoprocessing.geoprocessing as geo
from .solution_mapping import add_color_table
from .lucodes import activity_to_rgb
from .utils import tif_to_png



def make_agreement_maps(country_folder, optimization_folder="OptimizationResults"):
    country_name = os.path.basename(country_folder)
    agreement_map_destination = os.path.join(country_folder, optimization_folder,
                                             "FiguresAndMaps", "Agreement Maps")
    if not os.path.isdir(agreement_map_destination):
        os.makedirs(agreement_map_destination)
    
    solution_file = os.path.join(country_folder, optimization_folder, "solutions.h5")
    with h5py.File(solution_file, 'r') as s:
        sols = np.array(s['solutions']['maximization'])

    # get summary table
    df = pd.read_hdf(solution_file, 'summary_table')

    # find pareto points
    pareto_vars = ['production_value', 'biodiversity', 'net_ghg_co2e']
    df = find_pareto_points(df, pareto_vars)
    pareto_slice = np.array(df['ispareto'], dtype="int")
    sols = sols[:, pareto_slice]   # subset to solutions from pareto
    
    # reclass matrix
    reclass_table_file = "/Volumes/Extreme SSD/NCI/inputs/lu_scenario_codes.csv"
    reclass_df = pd.read_csv(reclass_table_file)
    reclassed_sols = reclassify_solutions(sols, reclass_df)
    
    # calculate the agreement stats
    modal_sol, modal_freq = find_modal_sol(reclassed_sols)
    
    # add to SDU map and make figure
    sdu_map_file = os.path.join(country_folder, "sdu_map", "sdu.shp")
    sdu_raster_file = os.path.join(country_folder, "sdu_map", "sdu.tif")
    lulc_raster_file = os.path.join(country_folder, "ScenarioMaps", "sustainable_current.tif")
    make_lu_type_raster_and_png(modal_sol, modal_freq, sdu_map_file, sdu_raster_file, lulc_raster_file,
                                agreement_map_destination)
    make_modal_freq_raster_and_png(modal_sol, modal_freq, sdu_map_file, sdu_raster_file, lulc_raster_file,
                                agreement_map_destination)
    
    

def find_pareto_points(df, pareto_vars, minimize_vars=[], colname="ispareto"):
    """
    Adds a column `colname` to `df` with values 1 for Pareto points and 0 for
    non-Pareto points.
    
    Assumes `df` has a column `sense`, where `df['sense'] == 0` identifies the baseline
    point.
    """
    
    pareto_point = np.ones(len(df))
    basedf = df[df['sense'] == 0]

    for var in pareto_vars:
        if var in minimize_vars:
            pareto_point = pareto_point * (df[var] <= basedf.loc[0, var])
        else:
            pareto_point = pareto_point * (df[var] >= basedf.loc[0, var])
    
    df[colname] = pareto_point
    
    return df


def reclassify_solutions(sols, reclass_df):
    """
    Converts sols from matrix with values for each specific management type
    to matrix with values for general landuse classes
    """
    reclassed_sols = sols.copy()
    for i, j in zip(reclass_df['solution_code'], reclass_df['lu_type_code']):
        reclassed_sols[reclassed_sols==i] = j
    
    return reclassed_sols


def find_modal_sol(sols, correct_for_jl_to_py=True):
    """
    Given a 2D numpy array `sols`, returns two 1D arrays, `modal_sol` and `modal_freq`. 
    `modal_sol` gives the most frequently occuring value per row in `sols`, and `modal_freq`
    gives the proportion of solutions with the modal value in each row.
    
    The kwarg `correct_for_jl_to_py` is there to subtract 1 from the value in the solution table, 
    which in the current version of NCI is generated by Julia, which is 1-indexed, rather than
    0-indexed like Python. So we want to subtract 1 so that the solutions line up with 
    Python indexing of the management options. 
    """
    
    def process_row(r):
        vals, counts = np.unique(r, return_counts=True)
        ix = np.where(counts==max(counts))[0][0]
        val = vals[ix] - 1 * correct_for_jl_to_py
        freq = counts[ix]/sum(counts)
        return (val, freq)

    tmp = [process_row(r) for r in sols]
    modal_sol = [x[0] for x in tmp]
    modal_freq = [x[1] for x in tmp]
    
    return modal_sol, modal_freq


def make_lu_type_raster_and_png(modal_sol, modal_freq, sdu_map_file, sdu_raster_file, 
                                lulc_raster_file, target_folder):
    if not os.path.isdir(target_folder):
        os.makedirs(target_folder)

    sdus = gpd.read_file(sdu_map_file)
    sdu_to_sol = np.zeros(int(max(sdus["SDUID"])+1))
    for sdu, sol in zip(sdus["SDUID"], modal_sol):
        sdu_to_sol[int(sdu)] = sol
    sdu_to_freq = np.zeros(int(max(sdus["SDUID"])+1))
    for sdu, freq in zip(sdus["SDUID"], modal_freq):
        sdu_to_freq[int(sdu)] = freq
    
    sdus['modal_sol'] = modal_sol
    sdus['modal_freq'] = modal_freq

    sdus.to_file(os.path.join(target_folder, "sdu_with_sols.shp"))
    
    if not os.path.isdir(target_folder):
        os.makedirs(target_folder)
    
    target_tif_file = os.path.join(target_folder, "modal_sol.tif")
    target_png_file = os.path.join(target_folder, "modal_sol.png")
    lulc_nodata = geo.get_raster_info(lulc_raster_file)['nodata']

    def pixel_op(sdu, lulc):
        sdu[sdu<0] = 0
        result = sdu_to_sol[sdu]
        result[lulc == lulc_nodata] = 0
        return result
    
    geo.raster_calculator(
        [(sdu_raster_file, 1), (lulc_raster_file, 1)],
        pixel_op,
        target_tif_file,
        gdal.GDT_Byte,
        0,
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES',
            'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )
    
    add_color_table(target_tif_file, activity_to_rgb)
    tif_to_png(target_tif_file, target_png_file)


def make_modal_freq_raster_and_png(modal_sol, modal_freq, sdu_map_file, sdu_raster_file,
                                   lulc_raster_file, target_folder):
    if not os.path.isdir(target_folder):
        os.makedirs(target_folder)

