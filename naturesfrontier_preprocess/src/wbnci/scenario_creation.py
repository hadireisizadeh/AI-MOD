import multiprocessing
import os
import sys
from itertools import chain
import json
import glob
import math
from typing import List
import shutil
import tempfile
import numpy as np
import geopandas as gpd
import osgeo.gdal as gdal
import pygeoprocessing.geoprocessing as pygeo
sys.path.append('..')
from wbnci.preprocessing import make_scenario_map, make_scenario_map_pv, make_intersection_mask
from wbnci.workers import worker
from wbnci.utils import read_to_array, read_lulc_table
# from .scenario_creation_cython_functions import restoration_cython
# note to self: to compile cython function:
# import numpy in python console
# run numpy.get_include()
# in terminal, export CFLAGS=-I/numpy/path
# cythonize -a -i scenario_creation_cython_functions.pyx


"""
All scenario creation functions require the same inputs:
    `files`: a dictionary specifying filepaths to various rasters (see below)
    `lu_codes`: a dictionary specifying lu codes corresponding to different
        categories, as generated by `utils.read_lulc_table`
    `target_folder`: filepath to desired output folder. 

`files` should contain:
    files = {
        'base_lulc': PATH,
        'sustainable_current': PATH,
        'restoration': PATH,
        'potential_vegetation': PATH,
        'slope_threshold_expansion': PATH,
        'slope_threshold_intensification': PATH,
        'rainfed_suitability': PATH,
        'irrigated_suitability': PATH,
        'riparian_buffer': PATH),
        'sustainable_irrigation': PATH,
        'soil_suitability': PATH,
        'grazing_suitability': PATH,
        'forestry_suitability': PATH
    }

NOTE: for the crop extensification scenarios, protected areas are incorporated in the 
suitability layers generated by `cropland_suitability_masks.py`. 

"""


GDT_Byte_NODATA = 7
all_lu_codes = [10, 11, 12, 20, 30, 40, 50, 60, 61, 62, 70, 71, 72, 80, 81, 82, 90,
                100, 110, 120, 121, 122, 130, 140, 150, 151, 152, 153, 160, 170, 180, 190,
                200, 201, 202, 210, 220]

ag_lucodes = [10, 11, 12, 15, 16, 20, 25, 26, 30, 40]
natural_lucodes = [50, 60, 61, 62, 70, 71, 72, 80, 81, 82, 90, 100, 110, 120, 121,
                   122, 130, 140, 150, 151, 152, 153, 160, 170, 180]

new_ag_codes = [15, 16, 25, 26]

lu_codes = read_lulc_table(os.path.join(os.path.dirname(__file__), 'lulc_codes.csv'))
pasture_codes = lu_codes['grazing_codes']
forestry_codes = lu_codes['forestry_codes']

crop_extensification_codes = np.unique(list(chain(natural_lucodes, pasture_codes, forestry_codes)))


def restoration(target_folder, succession_file, **files):
    """
    Reimplementation of restoration model with pygeoprocessing. Goal is to
    move away from reading the full raster in and save some memory footprint
    to run with TG on MSI.
    
    Assumption: base_lulc NODATA = 0 (so that it doesn't cause issues in idx lookup)
    
    """
    print("RUNNING NEW RESTORATION")
    succession_matrix = np.loadtxt(succession_file, dtype=np.int32, delimiter=',')
    code_to_sm_idx = np.zeros(max(all_lu_codes)+1, dtype="int")
    for idx, code in enumerate(natural_lucodes):
        code_to_sm_idx[code] = idx

    code_to_base_code = np.zeros(max(all_lu_codes)+1, dtype="int")
    for code, basecode in zip(lu_codes['all_codes'], lu_codes['base_codes']):
        code_to_base_code[code] = basecode
    
    def local_op(lu, pv):
        baselu = code_to_base_code[lu]
        to_pv = np.any([
            np.all([baselu > 0, baselu <= 40], axis=0),
            np.any([baselu==200, baselu==201, baselu==202], axis=0)
        ], axis=0)
        baselu[to_pv] = pv[to_pv]
        pvmask = np.all([pv>=50, pv<190], axis=0)
        successionmask = succession_matrix[code_to_sm_idx[baselu], code_to_sm_idx[pv]] == 1
        to_pv = np.all([
            lu > 40,
            lu < 190,
            pvmask,
            successionmask
        ], axis=0)
        baselu[to_pv] = pv[to_pv]
        return baselu
        
    needed_rasters = [
        'base_lulc',
        'potential_vegetation'
    ]

    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, "restoration.tif")
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])

    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )


def sustainable_current_intensity(target_folder, **files):
    """
    Creates a modified version of the current land use that replaces irrigated ag (20) with
    rainfed ag (10) where the Rosa dataset says irrigation is unsustainable. 
    
    Removes cropland from areas with protected status I-IV (pa == 1) or VI (pa == 3)
    
    uses files:
        base_lulc
        sustainable_irrigation
        protected_areas
        potential_vegetation

    """
    print("making sustainable_current.tif")
    
    def local_op(lu, si, pa, pv):
        result = np.copy(lu)
        # replace unsustainable irrigated cropland with rainfed cropland
        result[np.all([
            lu == 20,
            si == 0
        ], axis=0)] = 10
        
        # check for cropland in protected areas and convert to potential vegetation
        restore_ix = np.all([lu > 0,
                             lu < 30, 
                             np.any([pa == 1, pa == 3], axis=0)],
                            axis=0)
        result[restore_ix] = pv[restore_ix]
        
        return result
    
    needed_rasters = [
        'base_lulc',
        'sustainable_irrigation',
        'protected_areas',
        'potential_vegetation'
    ]
    
    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, "sustainable_current.tif")
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])
   
    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )


def extensification_current_practices(target_folder, **files):
    """
        + slope threshold (expansion), rainfed suitability, soil suitability
        + not protected area
        + set extensified pixels to 10
    """
    print("making extensification_current_practices.tif")
    
    needed_rasters = [
        'sustainable_current',
        'cropland_current_practices_suitability'
    ]

    def local_op(lu, cpsuit):
        result = np.empty(lu.shape)
        expand_ix = np.all(
            [np.isin(lu, crop_extensification_codes),
             cpsuit==1],
            axis=0)
        result[expand_ix] = 10
        result[~expand_ix] = lu[~expand_ix]
        return result
    
    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'extensification_current_practices.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])

    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )
    

def extensification_intensified_rainfed(target_folder, **files):
    """
        + slope threshold (intensified), rainfed suitability, soil suitability
        + not protected area
        + set pixels to intensified rainfed ag where suitable
    """
    
    print("making extensification_intensified_rainfed.tif")
    
    needed_rasters = [
        'sustainable_current',
        'cropland_intensified_rainfed_suitability'
    ]
    codes = np.array(list(
        chain(ag_lucodes, crop_extensification_codes)))

    def local_op(lu, rfsuit):
        result = np.empty(lu.shape)
        ag_pix = np.all([
            np.isin(lu, codes),
            rfsuit==1], 
            axis=0)
        result[ag_pix] = 15
        result[~ag_pix] = lu[~ag_pix]
        return result
    
    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'extensification_intensified_rainfed.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])

    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )


def extensification_intensified_irrigated(target_folder, **files):
    """
    sets valid intensified irrigated pixels to 25
    sets valid intensified rainfed pixels to 15
    """
    
    print("making extensification_intensified_irrigated.tif")

    codes = np.array(list(
        chain(ag_lucodes, crop_extensification_codes)))

    needed_rasters = [
        'sustainable_current', 
        'cropland_intensified_rainfed_suitability',
        'cropland_intensified_irrigated_suitability'
    ]

    def local_op(lu, rfsuit, irrsuit):
        """
        lu: land use
        st: slope threshold for intensification
        rfs: suitable for rainfed crops
        irs: suitable for irrigated crops
        si: sustainable irrigation mask
        ss: soil suitability mask
        """
        result = np.copy(lu)
        irr_pix = np.all([
            np.isin(lu, codes), irrsuit==1
        ], axis=0)
        result[irr_pix] = 25
        rf_pix = np.all([
            np.isin(lu, codes), irrsuit==0, rfsuit==1
        ], axis=0)
        result[rf_pix] = 15
        return result
    
    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'extensification_intensified_irrigated.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])

    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )


def extensification_bmps_rainfed(target_folder, **files):
    """
        + slope threshold (intensified), rainfed suitbility, soil suitability
        + set all ag pixels to 16
        + except where riparian buffer mask says to put buffers 
    """
    
    print("making extensification_bmps_rainfed.tif")
    
    codes = np.array(list(
        chain(ag_lucodes, crop_extensification_codes)))

    needed_rasters = [
        'sustainable_current',
        'cropland_intensified_rainfed_suitability',
        'riparian_buffer',
        'restoration']

    def local_op(lu, rfsuit, rb, pv):
        result = np.copy(lu)
        # first we expand cropland
        rf_pix = np.all([
            np.isin(lu, codes), rfsuit==1, rb==0
        ], axis=0)
        result[rf_pix] = 16

        # then fill cropland with riparian buffers
        rb_pix = np.all([
            np.isin(lu, ag_lucodes), rb==1
            ], axis=0)
        result[rb_pix] = pv[rb_pix]

        return result
    
    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'extensification_bmps_rainfed.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])

    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )


def extensification_bmps_irrigated(target_folder, **files):
    """
        Puts irrigated where sustainable, rainfed elsewhere
        Puts buffers along streams
    """
    print("making extensification_bmps_irrigated.tif")

    codes = np.array(list(
        chain(ag_lucodes, crop_extensification_codes)))

    needed_rasters = [
        'sustainable_current', 
        'cropland_intensified_rainfed_suitability',
        'cropland_intensified_irrigated_suitability',
        'riparian_buffer',
        'restoration'
        ]

    def local_op(lu, rfsuit, irrsuit, rb, pv):
        result = np.copy(lu)
        # expand irrigated cropland
        irr_pix = np.all([
            np.isin(lu, codes), irrsuit==1, rb==0, 
        ], axis=0)
        result[irr_pix] = 26
        # expand rainfed cropland 
        rf_pix = np.all([
            np.isin(lu, codes), irrsuit==0, rfsuit==1, rb==0
        ], axis=0)
        result[rf_pix] = 16
        # fill riparian buffers
        rb_pix = np.all([
            np.isin(lu, ag_lucodes), rb==1
        ], axis=0)
        result[rb_pix] = pv[rb_pix]

        return result
    
    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'extensification_bmps_irrigated.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])

    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )


def fixedarea_intensified_rainfed(target_folder, **files):
    """
    Maintains existing ag footprint, replaces all ag with class 15
    """

    print("fixedarea_intensified_rainfed")
    
    needed_rasters = [
        'sustainable_current',
        'cropland_intensified_rainfed_suitability'
    ]

    def local_op(lu, rfsuit):
        result = np.copy(lu)
        int_pix = np.all([
            np.isin(lu, ag_lucodes),
            rfsuit==1
        ], axis=0)
        result[int_pix] = 15
        return result

    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'fixedarea_intensified_rainfed.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])
   
    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )


def fixedarea_intensified_irrigated(target_folder, **files):
    """
    Puts intensified irrigated on current ag if in sustainable ag zone.
    Puts intensified rainfed on current ag, otherwise.
    """
    
    print("fixedarea_intensified_irrigated")
    
    needed_rasters = [
        'sustainable_current',
        'cropland_intensified_rainfed_suitability',
        'cropland_intensified_irrigated_suitability',
    ]
    
    def local_op(lu, rfsuit, irrsuit):
        result = np.copy(lu)
        result[np.all([
            np.isin(lu, ag_lucodes), irrsuit==1
        ], axis=0)] = 25
        result[np.all([
            np.isin(lu, ag_lucodes), irrsuit==0, rfsuit==1
        ], axis=0)] = 15
        return result

    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'fixedarea_intensified_irrigated.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])
   
    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )


def fixedarea_bmps_rainfed(target_folder, **files):
    """
    Replaces all existing ag with 16, unless in designated riparian buffers, which
    are restored
    """
    print("making fixedarea_bmps_rainfed")
    
    needed_rasters = [
        'sustainable_current',
        'cropland_intensified_rainfed_suitability',
        'riparian_buffer',
        'restoration'
    ]
    
    def local_op(lu, rfsuit, rb, pv):
        result = np.copy(lu)
        result[np.all([
            # np.isin(lu, ag_lucodes),
            rfsuit==1,
            lu > 0,
            lu <= 40,
            rb==0
        ], axis=0)] = 16
        rb_pix = rb == 1
        result[rb_pix] = pv[rb_pix]
        return result
    
    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'fixedarea_bmps_rainfed.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])
   
    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )


def fixedarea_bmps_irrigated(target_folder, **files):
    """
    Replaces sustainably intensified ag with 26, no-irrigation ag with 16,
    unless in designated riparian buffers, which are restored
    """
    print("making fixedarea_bmps_irrigated")
    
    needed_rasters = [
        'sustainable_current',
        'cropland_intensified_rainfed_suitability',
        'cropland_intensified_irrigated_suitability',
        'riparian_buffer',
        'restoration'
    ]
    
    def local_op(lu, rfsuit, irrsuit, rb, pv):
        result = np.copy(lu)
        result[np.all([
            irrsuit==1,
            lu > 0,
            lu <= 40,
            rb==0,
        ], axis=0)] = 26
        result[np.all([
            irrsuit==0,
            rfsuit==1,
            lu > 0,
            lu <= 40,
            rb==0,
        ], axis=0)] = 16
        rb_pix = rb == 1
        result[rb_pix] = pv[rb_pix]
        return result
    
    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'fixedarea_bmps_irrigated.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])
   
    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )


def grazing_expansion(target_folder, **files):
    """
    This scenario expands pasture (grazing) to all eligible pixels. Eligibility is defined
    as having a non-NODATA grazing value in the pixel. The way it's been generated, the returns map
    also functions as the mask layer by only providing a return where grazing is possible.
    
    Eligibility is also determined by protected status, which must be in Cat VI (pa==3) or 
    unprotected (pa==7).
    
    If a pixel is eligible, it is converted to 134 (grazed grassland) unless it is coming from
    some special cases (sparser habitat types), in which case it goes to the x+4 category.
    
    uses files:
        sustainable_current
        grazing_suitability
        restoration
        protected_areas
    
    """
    print("making grazing_expansion.tif")
    
    needed_rasters = [
        "sustainable_current",
        "grazing_suitability",
        "restoration",
        "protected_areas"
    ]
    
    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'grazing_expansion.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])

    grazing_nodata = pygeo.get_raster_info(files["grazing_suitability"])['nodata'][0]

    # grazing_eligible_lu_codes = list(chain(
    #     lu_codes['cropland_codes'], lu_codes['forestry_codes'], lu_codes['natural_codes']
    # ))
    grazing_eligible_lu_codes = lu_codes['natural_codes']
    special_case_codes = np.array([140, 150, 152, 153, 200, 201, 202])
    main_case_codes = np.array([c for c in grazing_eligible_lu_codes if 
                                (c not in special_case_codes) and (c not in lu_codes['fixed_codes'])])

    def local_op(lu, gs, rest, pa):
        result = np.copy(lu)
        to_134 = np.all([
            np.isin(rest, main_case_codes),
            gs > 0,
            pa >= 3
        ], axis=0)
        add_4 = np.all([
            np.isin(rest, special_case_codes),
            gs > 0,
            pa >= 3
        ], axis=0)
        result[to_134] = 134
        result[add_4] = rest[add_4] + 4
        
        return result

    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))

    )


def forestry_expansion(target_folder, **files):
    """
    This scenario expands forestry to all eligible pixels. Eligibility is defined as
    have a non-zero potential production value and as having a forestry class in the 
    potential vegetation layer

    Eligibility is also determined by protected status, which must be in Cat VI (pa==3) or 
    unprotected (pa==7).

    If a pixel is eligible, it is converted to its pv + 5
    """
    print("making forestry_expansion.tif")
    
    needed_rasters = [
        "sustainable_current",
        "forestry_suitability",
        "restoration",
        "protected_areas"
    ]
    
    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'forestry_expansion.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])

    forestry_nodata = pygeo.get_raster_info(files["forestry_suitability"])['nodata'][0]

    forestry_eligible_lu_codes = lu_codes["forestry_eligible_codes"]

    def local_op(lu, fs, rest, pa):
        result = np.copy(lu)
        add_5 = np.all([
            np.isin(rest, forestry_eligible_lu_codes),
            fs > 0,
            pa >= 3
        ], axis=0)
        result[add_5] = rest[add_5] + 5
        
        return result

    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))

    )


def all_urban(target_folder, **files):
    """
    Creates an all urban raster to be used to calculate the biodiversity zero value.
    """
    
    urban_code = 190
    
    ref_raster = files["sustainable_current"]
    ref_info = pygeo.get_raster_info(ref_raster)
    target_raster = os.path.join(target_folder, "all_urban.tif")
    pygeo.new_raster_from_base(ref_raster, target_raster, ref_info['datatype'],
                               ref_info['nodata'], fill_value_list=[urban_code])


def all_econ(target_folder, **files):
    """
    Creates a scenario all econ activity adopted, with preference to most harmful (to
    biodiversity) practices. Provides a "feasible" minimum biodiversity value.
    
    Specifically, prefers cropland > grazing > forestry depending on which practices are
    suitable in the given pixel.
    """

    needed_rasters = [
        "sustainable_current",
        "cropland_intensified_rainfed_suitability",
        "cropland_intensified_irrigated_suitability",
        "crop_value_intensified_rainfed",
        "crop_value_intensified_irrigated",
        "grazing_suitability",
        "forestry_suitability",
        "restoration"
    ]
    
    cropland_eligible_codes = np.array(list(
        chain(ag_lucodes, crop_extensification_codes)))

    src_bands = [(files[rn], 1) for rn in needed_rasters]
    target_file = os.path.join(target_folder, 'all_econ.tif')
    base_raster_info = pygeo.get_raster_info(files['base_lulc'])

    forestry_eligible_lu_codes = lu_codes["forestry_eligible_codes"]
    grazing_eligible_lu_codes = list(chain(
        lu_codes['forestry_codes'], lu_codes['natural_codes']
    ))   # note diff from grazing_expansion() - we don't allow cropland
    special_case_codes = np.array([140, 150, 152, 153, 200, 201, 202])
    main_case_codes = np.array([c for c in grazing_eligible_lu_codes if 
                                (c not in special_case_codes) and (c not in lu_codes['fixed_codes'])])

    def local_op(lu, rfsuit, irrsuit, rfval, irrval, grasuit, forsuit, pv):
        result = np.copy(lu)
        # expand grazing to suitable pixels
        to_134 = np.all([
            np.isin(pv, main_case_codes),
            grasuit > 0
        ], axis=0)
        add_4 = np.all([
            np.isin(pv, special_case_codes),
            grasuit > 0
        ], axis=0)
        result[to_134] = 134
        result[add_4] = pv[add_4] + 4

        # expand cropland where possible if no grazing
        # first check for irrigated
        irr_pix = np.all([
            ~(grasuit>0),
            np.isin(lu, cropland_eligible_codes),
            irrsuit==1, irrval>0], 
            axis=0)
        result[irr_pix] = 25
        
        # rainfed where we didn't put irrigated
        rf_pix = np.all([
            ~(grasuit>0),
            np.isin(lu, cropland_eligible_codes),
            result!=25, rfsuit==1, rfval>0], 
            axis=0)
        result[rf_pix] = 15
        
        # expand forestry to remaining suitable pixels
        add_5 = np.all([
            np.isin(pv, forestry_eligible_lu_codes),
            rfsuit==0,
            ~(grasuit>0),
            forsuit>0,
        ], axis=0)
        result[add_5] = pv[add_5] + 5

        return result


    pygeo.raster_calculator(
        src_bands,
        local_op,
        target_file,
        base_raster_info['datatype'],
        base_raster_info['nodata'][0],
        raster_driver_creation_tuple=('GTIFF', ('TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
                'BLOCKXSIZE=256', 'BLOCKYSIZE=256'))
    )
